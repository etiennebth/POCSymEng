<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>symengine: Teuchos::Ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">symengine
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Teuchos</b></li><li class="navelem"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="class_teuchos_1_1_ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Teuchos::Ptr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Simple wrapper class for raw pointers to single objects where no persisting relationship exists.  
 <a href="class_teuchos_1_1_ptr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_teuchos___ptr_decl_8hpp_source.html">Teuchos_PtrDecl.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af8a805c872b3e76cd11bfdc72deb02b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#af8a805c872b3e76cd11bfdc72deb02b8">Ptr</a> (ENull null_in=null)</td></tr>
<tr class="memdesc:af8a805c872b3e76cd11bfdc72deb02b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construct to NULL.  <a href="#af8a805c872b3e76cd11bfdc72deb02b8">More...</a><br /></td></tr>
<tr class="separator:af8a805c872b3e76cd11bfdc72deb02b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388092502cdcaf286a1515f2982b2876"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a388092502cdcaf286a1515f2982b2876">Ptr</a> (T *<a class="el" href="class_teuchos_1_1_ptr.html#af0e5dc557877f5a92a86999696af8876">ptr</a>)</td></tr>
<tr class="memdesc:a388092502cdcaf286a1515f2982b2876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct given a raw pointer.  <a href="#a388092502cdcaf286a1515f2982b2876">More...</a><br /></td></tr>
<tr class="separator:a388092502cdcaf286a1515f2982b2876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36d2c448bf568f24c9a3bc389eaec90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#aa36d2c448bf568f24c9a3bc389eaec90">Ptr</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;<a class="el" href="class_teuchos_1_1_ptr.html#af0e5dc557877f5a92a86999696af8876">ptr</a>)</td></tr>
<tr class="memdesc:aa36d2c448bf568f24c9a3bc389eaec90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct from same type.  <a href="#aa36d2c448bf568f24c9a3bc389eaec90">More...</a><br /></td></tr>
<tr class="separator:aa36d2c448bf568f24c9a3bc389eaec90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9717930ce7a53405dd76714a4f672e"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a8a9717930ce7a53405dd76714a4f672e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a8a9717930ce7a53405dd76714a4f672e">Ptr</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt; &amp;<a class="el" href="class_teuchos_1_1_ptr.html#af0e5dc557877f5a92a86999696af8876">ptr</a>)</td></tr>
<tr class="memdesc:a8a9717930ce7a53405dd76714a4f672e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct from another type.  <a href="#a8a9717930ce7a53405dd76714a4f672e">More...</a><br /></td></tr>
<tr class="separator:a8a9717930ce7a53405dd76714a4f672e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370eb76e7341bfab9c1e9fa9d669b59a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a370eb76e7341bfab9c1e9fa9d669b59a">operator=</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;<a class="el" href="class_teuchos_1_1_ptr.html#af0e5dc557877f5a92a86999696af8876">ptr</a>)</td></tr>
<tr class="memdesc:a370eb76e7341bfab9c1e9fa9d669b59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shallow copy of the underlying pointer.  <a href="#a370eb76e7341bfab9c1e9fa9d669b59a">More...</a><br /></td></tr>
<tr class="separator:a370eb76e7341bfab9c1e9fa9d669b59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d960aa39204ebbbefce310459eeda3d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a9d960aa39204ebbbefce310459eeda3d">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a9d960aa39204ebbbefce310459eeda3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer (<code>-&gt;</code>) access to members of underlying object.  <a href="#a9d960aa39204ebbbefce310459eeda3d">More...</a><br /></td></tr>
<tr class="separator:a9d960aa39204ebbbefce310459eeda3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6382badbb49ba342298003c0e15eb62"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#ad6382badbb49ba342298003c0e15eb62">operator*</a> () const</td></tr>
<tr class="memdesc:ad6382badbb49ba342298003c0e15eb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference the underlying object.  <a href="#ad6382badbb49ba342298003c0e15eb62">More...</a><br /></td></tr>
<tr class="separator:ad6382badbb49ba342298003c0e15eb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55b31654912da0d38c4d3f6b806d923"><td class="memItemLeft" align="right" valign="top"><a id="ae55b31654912da0d38c4d3f6b806d923"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#ae55b31654912da0d38c4d3f6b806d923">get</a> () const</td></tr>
<tr class="memdesc:ae55b31654912da0d38c4d3f6b806d923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw C++ pointer to the underlying object. <br /></td></tr>
<tr class="separator:ae55b31654912da0d38c4d3f6b806d923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3595081796130e75a7d79acf2af17c64"><td class="memItemLeft" align="right" valign="top"><a id="a3595081796130e75a7d79acf2af17c64"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a3595081796130e75a7d79acf2af17c64">getRawPtr</a> () const</td></tr>
<tr class="memdesc:a3595081796130e75a7d79acf2af17c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw C++ pointer to the underlying object. <br /></td></tr>
<tr class="separator:a3595081796130e75a7d79acf2af17c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199b7bea88d84faeee7c03da4ccd1f4c"><td class="memItemLeft" align="right" valign="top"><a id="a199b7bea88d84faeee7c03da4ccd1f4c"></a>
const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a199b7bea88d84faeee7c03da4ccd1f4c">assert_not_null</a> () const</td></tr>
<tr class="memdesc:a199b7bea88d84faeee7c03da4ccd1f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws <code>std::logic_error</code> if <code>this-&gt;<a class="el" href="class_teuchos_1_1_ptr.html#ae55b31654912da0d38c4d3f6b806d923" title="Get the raw C++ pointer to the underlying object. ">get()</a>==NULL</code>, otherwise returns reference to <code>*this</code>. <br /></td></tr>
<tr class="separator:a199b7bea88d84faeee7c03da4ccd1f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e5dc557877f5a92a86999696af8876"><td class="memItemLeft" align="right" valign="top"><a id="af0e5dc557877f5a92a86999696af8876"></a>
const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#af0e5dc557877f5a92a86999696af8876">ptr</a> () const</td></tr>
<tr class="memdesc:af0e5dc557877f5a92a86999696af8876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of *this. <br /></td></tr>
<tr class="separator:af0e5dc557877f5a92a86999696af8876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32737f060c9446397844843a92281125"><td class="memItemLeft" align="right" valign="top"><a id="a32737f060c9446397844843a92281125"></a>
<a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; const T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a32737f060c9446397844843a92281125">getConst</a> () const</td></tr>
<tr class="memdesc:a32737f060c9446397844843a92281125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Ptr&lt;const T&gt; version of *this. <br /></td></tr>
<tr class="separator:a32737f060c9446397844843a92281125"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8a78259ca8e170a42932a45e412b88e1"><td class="memTemplParams" colspan="2"><a id="a8a78259ca8e170a42932a45e412b88e1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a78259ca8e170a42932a45e412b88e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a8a78259ca8e170a42932a45e412b88e1">outArg</a> (T &amp;arg)</td></tr>
<tr class="memdesc:a8a78259ca8e170a42932a45e412b88e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a non-persisting (required or optional) output argument for a function call. <br /></td></tr>
<tr class="separator:a8a78259ca8e170a42932a45e412b88e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928ef67284e94e5ca1c41b81084103cb"><td class="memTemplParams" colspan="2"><a id="a928ef67284e94e5ca1c41b81084103cb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a928ef67284e94e5ca1c41b81084103cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a928ef67284e94e5ca1c41b81084103cb">inOutArg</a> (T &amp;arg)</td></tr>
<tr class="memdesc:a928ef67284e94e5ca1c41b81084103cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a non-persisting (required or optional) input/output argument for a function call. <br /></td></tr>
<tr class="separator:a928ef67284e94e5ca1c41b81084103cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9418d4e46ac7b589f8de2ab89bc56e"><td class="memTemplParams" colspan="2"><a id="acb9418d4e46ac7b589f8de2ab89bc56e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb9418d4e46ac7b589f8de2ab89bc56e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#acb9418d4e46ac7b589f8de2ab89bc56e">inoutArg</a> (T &amp;arg)</td></tr>
<tr class="memdesc:acb9418d4e46ac7b589f8de2ab89bc56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a non-persisting (required or optional) input/output argument for a function call. <br /></td></tr>
<tr class="separator:acb9418d4e46ac7b589f8de2ab89bc56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10378147716e47d52786911bab658493"><td class="memTemplParams" colspan="2"><a id="a10378147716e47d52786911bab658493"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10378147716e47d52786911bab658493"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a10378147716e47d52786911bab658493">ptrInArg</a> (T &amp;arg)</td></tr>
<tr class="memdesc:a10378147716e47d52786911bab658493"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a general <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> input argument for a function call from a reference. <br /></td></tr>
<tr class="separator:a10378147716e47d52786911bab658493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba487b250aab0a2dddb732cd4a3b951"><td class="memTemplParams" colspan="2"><a id="a4ba487b250aab0a2dddb732cd4a3b951"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ba487b250aab0a2dddb732cd4a3b951"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a4ba487b250aab0a2dddb732cd4a3b951">optInArg</a> (T &amp;arg)</td></tr>
<tr class="memdesc:a4ba487b250aab0a2dddb732cd4a3b951"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a non-persisting non-const optional input argument for a function call. <br /></td></tr>
<tr class="separator:a4ba487b250aab0a2dddb732cd4a3b951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9066e6cad7141e920481b77522e1cc4"><td class="memTemplParams" colspan="2"><a id="ae9066e6cad7141e920481b77522e1cc4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9066e6cad7141e920481b77522e1cc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#ae9066e6cad7141e920481b77522e1cc4">constOptInArg</a> (T &amp;arg)</td></tr>
<tr class="memdesc:ae9066e6cad7141e920481b77522e1cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a non-persisting const optional input argument for a function call. <br /></td></tr>
<tr class="separator:ae9066e6cad7141e920481b77522e1cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811b10232b631fdcb02a543a17d0bb1a"><td class="memTemplParams" colspan="2"><a id="a811b10232b631fdcb02a543a17d0bb1a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a811b10232b631fdcb02a543a17d0bb1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a811b10232b631fdcb02a543a17d0bb1a">ptrFromRef</a> (T &amp;arg)</td></tr>
<tr class="memdesc:a811b10232b631fdcb02a543a17d0bb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pointer to a object from an object reference. <br /></td></tr>
<tr class="separator:a811b10232b631fdcb02a543a17d0bb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7234a3ac243772a707da53d011276fb"><td class="memTemplParams" colspan="2"><a id="af7234a3ac243772a707da53d011276fb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af7234a3ac243772a707da53d011276fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#af7234a3ac243772a707da53d011276fb">ptr</a> (T *p)</td></tr>
<tr class="memdesc:af7234a3ac243772a707da53d011276fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pointer to an object from a raw pointer. <br /></td></tr>
<tr class="separator:af7234a3ac243772a707da53d011276fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7628e3dd1c9920942afe111dc4cb9a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b7628e3dd1c9920942afe111dc4cb9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a6b7628e3dd1c9920942afe111dc4cb9a">constPtr</a> (T &amp;arg)</td></tr>
<tr class="memdesc:a6b7628e3dd1c9920942afe111dc4cb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pointer from a const object given a non-const object reference.  <a href="#a6b7628e3dd1c9920942afe111dc4cb9a">More...</a><br /></td></tr>
<tr class="separator:a6b7628e3dd1c9920942afe111dc4cb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d8b299b372c1caf467575beebdd7ea"><td class="memTemplParams" colspan="2"><a id="a78d8b299b372c1caf467575beebdd7ea"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a78d8b299b372c1caf467575beebdd7ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a78d8b299b372c1caf467575beebdd7ea">is_null</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a78d8b299b372c1caf467575beebdd7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()==NULL</code>. <br /></td></tr>
<tr class="separator:a78d8b299b372c1caf467575beebdd7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2def51ff22310fcac0f7ad3f157586ff"><td class="memTemplParams" colspan="2"><a id="a2def51ff22310fcac0f7ad3f157586ff"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2def51ff22310fcac0f7ad3f157586ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a2def51ff22310fcac0f7ad3f157586ff">nonnull</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a2def51ff22310fcac0f7ad3f157586ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()!=NULL</code> <br /></td></tr>
<tr class="separator:a2def51ff22310fcac0f7ad3f157586ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24408f633b6bd788daaee868ce3019f9"><td class="memTemplParams" colspan="2"><a id="a24408f633b6bd788daaee868ce3019f9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a24408f633b6bd788daaee868ce3019f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a24408f633b6bd788daaee868ce3019f9">operator==</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;p, ENull)</td></tr>
<tr class="memdesc:a24408f633b6bd788daaee868ce3019f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()==NULL</code>. <br /></td></tr>
<tr class="separator:a24408f633b6bd788daaee868ce3019f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80d826cbb863af50c0beb1aa02ad92b"><td class="memTemplParams" colspan="2"><a id="ab80d826cbb863af50c0beb1aa02ad92b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab80d826cbb863af50c0beb1aa02ad92b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#ab80d826cbb863af50c0beb1aa02ad92b">operator!=</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;p, ENull)</td></tr>
<tr class="memdesc:ab80d826cbb863af50c0beb1aa02ad92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>p.get()!=NULL</code>. <br /></td></tr>
<tr class="separator:ab80d826cbb863af50c0beb1aa02ad92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a6bdc45c6acef84001efd972650b6f"><td class="memTemplParams" colspan="2"><a id="ad6a6bdc45c6acef84001efd972650b6f"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ad6a6bdc45c6acef84001efd972650b6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#ad6a6bdc45c6acef84001efd972650b6f">operator==</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T1 &gt; &amp;p1, const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt; &amp;p2)</td></tr>
<tr class="memdesc:ad6a6bdc45c6acef84001efd972650b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> objects point to the same object. <br /></td></tr>
<tr class="separator:ad6a6bdc45c6acef84001efd972650b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec67907091db072c4975d7302dd2d15e"><td class="memTemplParams" colspan="2"><a id="aec67907091db072c4975d7302dd2d15e"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aec67907091db072c4975d7302dd2d15e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#aec67907091db072c4975d7302dd2d15e">operator!=</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T1 &gt; &amp;p1, const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt; &amp;p2)</td></tr>
<tr class="memdesc:aec67907091db072c4975d7302dd2d15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> objects do not point to the same object. <br /></td></tr>
<tr class="separator:aec67907091db072c4975d7302dd2d15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033059947d94f9f7324dab94468fea73"><td class="memTemplParams" colspan="2">template&lt;class T2 , class T1 &gt; </td></tr>
<tr class="memitem:a033059947d94f9f7324dab94468fea73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a033059947d94f9f7324dab94468fea73">ptr_implicit_cast</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T1 &gt; &amp;p1)</td></tr>
<tr class="memdesc:a033059947d94f9f7324dab94468fea73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit cast of underlying <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> type from <code>T1*</code> to <code>T2*</code>.  <a href="#a033059947d94f9f7324dab94468fea73">More...</a><br /></td></tr>
<tr class="separator:a033059947d94f9f7324dab94468fea73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed315c8d8d027bfc40af25da05ae9d93"><td class="memTemplParams" colspan="2">template&lt;class T2 , class T1 &gt; </td></tr>
<tr class="memitem:aed315c8d8d027bfc40af25da05ae9d93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#aed315c8d8d027bfc40af25da05ae9d93">ptr_static_cast</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T1 &gt; &amp;p1)</td></tr>
<tr class="memdesc:aed315c8d8d027bfc40af25da05ae9d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static cast of underlying <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> type from <code>T1*</code> to <code>T2*</code>.  <a href="#aed315c8d8d027bfc40af25da05ae9d93">More...</a><br /></td></tr>
<tr class="separator:aed315c8d8d027bfc40af25da05ae9d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01039f443e5b66385cf1aa008947df7a"><td class="memTemplParams" colspan="2">template&lt;class T2 , class T1 &gt; </td></tr>
<tr class="memitem:a01039f443e5b66385cf1aa008947df7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a01039f443e5b66385cf1aa008947df7a">ptr_const_cast</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T1 &gt; &amp;p1)</td></tr>
<tr class="memdesc:a01039f443e5b66385cf1aa008947df7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant cast of underlying <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> type from <code>T1*</code> to <code>T2*</code>.  <a href="#a01039f443e5b66385cf1aa008947df7a">More...</a><br /></td></tr>
<tr class="separator:a01039f443e5b66385cf1aa008947df7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18883afb9a2a07fe33f3f359a0622a03"><td class="memTemplParams" colspan="2">template&lt;class T2 , class T1 &gt; </td></tr>
<tr class="memitem:a18883afb9a2a07fe33f3f359a0622a03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#a18883afb9a2a07fe33f3f359a0622a03">ptr_dynamic_cast</a> (const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T1 &gt; &amp;p1, bool throw_on_fail=false)</td></tr>
<tr class="memdesc:a18883afb9a2a07fe33f3f359a0622a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast of underlying <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> type from <code>T1*</code> to <code>T2*</code>.  <a href="#a18883afb9a2a07fe33f3f359a0622a03">More...</a><br /></td></tr>
<tr class="separator:a18883afb9a2a07fe33f3f359a0622a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb88db7902ac82184de3175eb5a662fc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afb88db7902ac82184de3175eb5a662fc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teuchos_1_1_ptr.html#afb88db7902ac82184de3175eb5a662fc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:afb88db7902ac82184de3175eb5a662fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream inserter.  <a href="#afb88db7902ac82184de3175eb5a662fc">More...</a><br /></td></tr>
<tr class="separator:afb88db7902ac82184de3175eb5a662fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class Teuchos::Ptr&lt; T &gt;</h3>

<p>Simple wrapper class for raw pointers to single objects where no persisting relationship exists. </p>
<p>This class is meant to replace all but the lowest-level use of raw pointers that point to single objects where the use of <code><a class="el" href="class_teuchos_1_1_r_c_p.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> is not justified for performance or semantic reasons. When built in optimized mode, this class should impart little time overhead and should be exactly equivalent in the memory footprint to a raw C++ pointer and the only extra runtime overhead will be the default initalization to NULL.</p>
<p>The main advantages of using this class over a raw pointer however are:</p>
<ul>
<li>
<p class="startli"><code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> objects always default construct to null</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> objects will throw exceptions on attempts to dereference the underlying null pointer when debugging support is compiled in.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> does not allow array-like operations like <code>ptr[i]</code>, <code>++ptr</code> or <code>ptr+i</code> that can only result in disaster when the a pointer points to only a single object that can not be assumed to be part of an array of objects.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> is part of a system of types defined in <code>Teuchos</code> that keeps your code away from raw pointers which are the cause of most defects in C++ code.</p>
<p class="endli"></p>
</li>
</ul>
<p>Debugging support is compiled in when the macro <code>TEUCHOS_DEBUG</code> is defined which happens automatically when <code>&ndash;enable-teuchos-debug</code> is specified on the configure line. When debugging support is not compiled in, the only overhead imparted by this class is it's default initialization to null. Therefore, this class can provide for very high performance on optimized builds of the code.</p>
<p>An implicit conversion from a raw pointer to a <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> object is okay since we don't assume any ownership of the object, hense the constructor taking a raw pointer is not declared explicit. However, this class does not support an implicit conversion to a raw pointer since we want to limit the exposure of raw pointers in our software. If we have to convert back to a raw pointer, then we want to make that explicit by calling <code><a class="el" href="class_teuchos_1_1_ptr.html#ae55b31654912da0d38c4d3f6b806d923" title="Get the raw C++ pointer to the underlying object. ">get()</a></code>.</p>
<p>This class should be used to replace most raw uses of C++ pointers to single objects where using the <code><a class="el" href="class_teuchos_1_1_r_c_p.html" title="Smart reference counting pointer class for automatic garbage collection. ">RCP</a></code> class is not appropriate, unless the runtime cost of null-initialization it too expensive. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af8a805c872b3e76cd11bfdc72deb02b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a805c872b3e76cd11bfdc72deb02b8">&#9670;&nbsp;</a></span>Ptr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_teuchos_1_1_ptr.html">Teuchos::Ptr</a>&lt; T &gt;::<a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a> </td>
          <td>(</td>
          <td class="paramtype">ENull&#160;</td>
          <td class="paramname"><em>null_in</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default construct to NULL. </p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="class_teuchos_1_1_ptr.html#ae55b31654912da0d38c4d3f6b806d923" title="Get the raw C++ pointer to the underlying object. ">get()</a> == NULL</code> </li>
</ul>

</div>
</div>
<a id="a388092502cdcaf286a1515f2982b2876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388092502cdcaf286a1515f2982b2876">&#9670;&nbsp;</a></span>Ptr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_teuchos_1_1_ptr.html">Teuchos::Ptr</a>&lt; T &gt;::<a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct given a raw pointer. </p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="class_teuchos_1_1_ptr.html#ae55b31654912da0d38c4d3f6b806d923" title="Get the raw C++ pointer to the underlying object. ">get()</a> == ptr</code> </li>
</ul>
<p>Note: This constructor is declared <code>explicit</code> so there is no implicit conversion from a raw C++ pointer to a <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> object. This is meant to avoid cases where an uninitialized pointer is used to implicitly initialize one of these objects. </p>

</div>
</div>
<a id="aa36d2c448bf568f24c9a3bc389eaec90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36d2c448bf568f24c9a3bc389eaec90">&#9670;&nbsp;</a></span>Ptr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_teuchos_1_1_ptr.html">Teuchos::Ptr</a>&lt; T &gt;::<a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy construct from same type. </p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="class_teuchos_1_1_ptr.html#ae55b31654912da0d38c4d3f6b806d923" title="Get the raw C++ pointer to the underlying object. ">get()</a> == ptr.get()</code> </li>
</ul>

</div>
</div>
<a id="a8a9717930ce7a53405dd76714a4f672e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9717930ce7a53405dd76714a4f672e">&#9670;&nbsp;</a></span>Ptr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_teuchos_1_1_ptr.html">Teuchos::Ptr</a>&lt; T &gt;::<a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy construct from another type. </p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="class_teuchos_1_1_ptr.html#ae55b31654912da0d38c4d3f6b806d923" title="Get the raw C++ pointer to the underlying object. ">get()</a> == ptr.get()</code> (unless virtual base classes are involved) </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad6382badbb49ba342298003c0e15eb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6382badbb49ba342298003c0e15eb62">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_teuchos_1_1_ptr.html">Teuchos::Ptr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference the underlying object. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="class_teuchos_1_1_ptr.html#ae55b31654912da0d38c4d3f6b806d923" title="Get the raw C++ pointer to the underlying object. ">get()</a> != NULL</code> (throws <code>std::logic_error</code>) </li>
</ul>

</div>
</div>
<a id="a9d960aa39204ebbbefce310459eeda3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d960aa39204ebbbefce310459eeda3d">&#9670;&nbsp;</a></span>operator->()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_teuchos_1_1_ptr.html">Teuchos::Ptr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer (<code>-&gt;</code>) access to members of underlying object. </p>
<p><b>Preconditions:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="class_teuchos_1_1_ptr.html#ae55b31654912da0d38c4d3f6b806d923" title="Get the raw C++ pointer to the underlying object. ">get()</a> != NULL</code> (throws <code>std::logic_error</code>) </li>
</ul>

</div>
</div>
<a id="a370eb76e7341bfab9c1e9fa9d669b59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370eb76e7341bfab9c1e9fa9d669b59a">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp; <a class="el" href="class_teuchos_1_1_ptr.html">Teuchos::Ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shallow copy of the underlying pointer. </p>
<p><b>Postconditons:</b></p><ul>
<li>
<code>this-&gt;<a class="el" href="class_teuchos_1_1_ptr.html#ae55b31654912da0d38c4d3f6b806d923" title="Get the raw C++ pointer to the underlying object. ">get()</a> == ptr.get()</code> </li>
</ul>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6b7628e3dd1c9920942afe111dc4cb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7628e3dd1c9920942afe111dc4cb9a">&#9670;&nbsp;</a></span>constPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; const T &gt; constPtr </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pointer from a const object given a non-const object reference. </p>
<p><b>Warning!</b> Do not call this function if <code>T</code> is already const or a compilation error will occur! </p>

</div>
</div>
<a id="afb88db7902ac82184de3175eb5a662fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb88db7902ac82184de3175eb5a662fc">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output stream inserter. </p>
<p>The implementation of this function just print pointer addresses and therefore puts no restrictions on the data types involved. </p>

</div>
</div>
<a id="a01039f443e5b66385cf1aa008947df7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01039f443e5b66385cf1aa008947df7a">&#9670;&nbsp;</a></span>ptr_const_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T2 , class T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt; ptr_const_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant cast of underlying <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<p>This function will compile only if (<code>const_cast&lt;T2*&gt;(p1.get());</code>) compiles. </p>

</div>
</div>
<a id="a18883afb9a2a07fe33f3f359a0622a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18883afb9a2a07fe33f3f359a0622a03">&#9670;&nbsp;</a></span>ptr_dynamic_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T2 , class T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt; ptr_dynamic_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throw_on_fail</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic cast of underlying <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>[in] The smart pointer casting from</td></tr>
    <tr><td class="paramname">throw_on_fail</td><td>[in] If <code>true</code> then if the cast fails (for <code>p1.get()!=NULL) then a <code>std::bad_cast</code> std::exception is thrown with a very informative error message.</code></td></tr>
  </table>
  </dd>
</dl>
<p><b>Postconditions:</b></p><ul>
<li>
<code> If <code>( p1.get()!=NULL &amp;&amp; throw_on_fail==true &amp;&amp; dynamic_cast&lt;T2*&gt;(p1.get())==NULL ) == true</code> then an <code>std::bad_cast</code> std::exception is thrown with a very informative error message. </code></li>
<li>
<code> If <code>( p1.get()!=NULL &amp;&amp; dynamic_cast&lt;T2*&gt;(p1.get())!=NULL ) == true</code> then <code>return.get() == dynamic_cast&lt;T2*&gt;(p1.get())</code>. </code></li>
<li>
<code> If <code>( p1.get()!=NULL &amp;&amp; throw_on_fail==false &amp;&amp; dynamic_cast&lt;T2*&gt;(p1.get())==NULL ) == true</code> then <code>return.get() == NULL</code>. </code></li>
<li>
<code> If <code>( p1.get()==NULL ) == true</code> then <code>return.get() == NULL</code>. </code></li>
</ul>
<p><code>This function will compile only if (<code>dynamic_cast&lt;T2*&gt;(p1.get());</code>) compiles. </code></p>

</div>
</div>
<a id="a033059947d94f9f7324dab94468fea73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033059947d94f9f7324dab94468fea73">&#9670;&nbsp;</a></span>ptr_implicit_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T2 , class T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt; ptr_implicit_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit cast of underlying <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<p>The function will compile only if (<code>T2* p2 = p1.get();</code>) compiles.</p>
<p>This is to be used for conversions up an inheritance hierarchy and from non-const to const and any other standard implicit pointer conversions allowed by C++. </p>

</div>
</div>
<a id="aed315c8d8d027bfc40af25da05ae9d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed315c8d8d027bfc40af25da05ae9d93">&#9670;&nbsp;</a></span>ptr_static_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T2 , class T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T2 &gt; ptr_static_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_teuchos_1_1_ptr.html">Ptr</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static cast of underlying <code><a class="el" href="class_teuchos_1_1_ptr.html" title="Simple wrapper class for raw pointers to single objects where no persisting relationship exists...">Ptr</a></code> type from <code>T1*</code> to <code>T2*</code>. </p>
<p>The function will compile only if (<code>static_cast&lt;T2*&gt;(p1.get());</code>) compiles.</p>
<p>This can safely be used for conversion down an inheritance hierarchy with polymorphic types only if <code>dynamic_cast&lt;T2&gt;(p1.get()) == static_cast&lt;T2&gt;(p1.get())</code>. If not then you have to use <code>ptr_dynamic_cast<code>&lt;T2&gt;(p1)</code>. </code></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/etienne/src/symengine/symengine/utilities/teuchos/<a class="el" href="_teuchos___ptr_decl_8hpp_source.html">Teuchos_PtrDecl.hpp</a></li>
<li>/home/etienne/src/symengine/symengine/utilities/teuchos/<a class="el" href="_teuchos___ptr_8hpp_source.html">Teuchos_Ptr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
